#include "decodethread.h"
#include <ctime>
#include <QTime>

DecodeThread::DecodeThread(QObject *parent) :
    QThread(parent)
{
    InitVars();
    initCodec();
    vthread = NULL;
}
/**
   \brief Constructor - opens directly a video
**/

DecodeThread::~DecodeThread()
{
    close();
}

void DecodeThread::InitVars()
{
    ok=false;
    pFormatCtx=0;
    pVideoCodecCtx=0;
    pAudioCodecCtx=0;
    pVideoCodec=0;
    pAudioCodec=0;
    videoMutex = new QMutex;
    audioMutex = new QMutex;
}

void DecodeThread::close()
{
   if(!ok)
      return;

   // Close the codec
   if(pVideoCodecCtx)
      avcodec_close(pVideoCodecCtx);
   if(pAudioCodecCtx)
      avcodec_close(pAudioCodecCtx);

   // Close the video file
   if(pFormatCtx)
      avformat_close_input(&pFormatCtx);

   InitVars();
}


bool DecodeThread::initCodec()
{


    //cout << "License: " << avformat_license() << endl;
    //cout << "AVCodec version: " << avformat_version() << endl;
    //cout << "AVFormat configuration: " << avformat_configuration() << endl;

    return true;
}

bool DecodeThread::openFile(QString filename)
{
   // Close last video..
   close();
    fileName = filename;



   // Open video file
   if(avformat_open_input(&pFormatCtx, filename.toStdString().c_str(), NULL, NULL)!=0)
       return false; // Couldn't open file

   // Retrieve stream information
   if(avformat_find_stream_info(pFormatCtx, NULL)<0)
       return false; // Couldn't find stream information


   // Find the first video stream
    videoStream = av_find_best_stream(pFormatCtx, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0);;
   /*
   for(unsigned i=0; i<pFormatCtx->nb_streams; i++)
       if(pFormatCtx->streams[i]->codec->codec_type==AVMEDIA_TYPE_VIDEO)
       {
           videoStream=i;
           break;
       }
       */
   if(videoStream==-1)
       return false; // Didn't find a video stream
    audioStream = av_find_best_stream(pFormatCtx, AVMEDIA_TYPE_AUDIO, -1, videoStream, NULL, 0);

   // Get a pointer to the codec context for the video stream
   pVideoCodecCtx=pFormatCtx->streams[videoStream]->codec;
   pAudioCodecCtx=pFormatCtx->streams[audioStream]->codec;
   // Find the decoder for the video stream
   pVideoCodec=avcodec_find_decoder(pVideoCodecCtx->codec_id);
   pAudioCodec=avcodec_find_decoder(pAudioCodecCtx->codec_id);
   if(pVideoCodec==NULL && pAudioCodec==NULL)
       return false; // Codec not found

   // Open codec
   if(avcodec_open2(pVideoCodecCtx, pVideoCodec, NULL)<0)// && avcodec_open2(pAudioCodecCtx, pAudioCodec, NULL)<0)
       return false; // Could not open codec

   // Hack to correct wrong frame rates that seem to be generated by some
   // codecs
   if(pVideoCodecCtx->time_base.num>1000 && pVideoCodecCtx->time_base.den==1)
     pVideoCodecCtx->time_base.den=1000;

   cout << "iformat: " << pFormatCtx->iformat->name << endl;
   cout << "video codec: " << avcodec_get_name(pVideoCodecCtx->codec_id) << endl;
   cout << "audio codec: " << avcodec_get_name(pAudioCodecCtx->codec_id) << endl;

   cout << "duration: " << pFormatCtx->duration << endl;
   cout << "start_time: " << pFormatCtx->start_time << endl;
   cout << "start_time_real: " << pFormatCtx->start_time_realtime << endl;

   //seekMs(350000+pFormatCtx->start_time/1000);
   srand((unsigned int)time(0));
   cout << rand();
   //seekMs((rand()%(pFormatCtx->duration/1000000))*1000);

   ok=true;
   return true;
}

void DecodeThread::genVideoThread()
{
   vthread = new VideoThread(videoQueue, videoMutex, pVideoCodecCtx, pFormatCtx, videoStream);
}

/**
  \brief Seek to millisecond
**/
bool DecodeThread::seekMs(int tsms)
{
   //printf("**** SEEK TO ms %d. LLT: %d. LT: %d. LLF: %d. LF: %d. LastFrameOk: %d\n",tsms,LastLastFrameTime,LastFrameTime,LastLastFrameNumber,LastFrameNumber,(int)LastFrameOk);
   cout << "tsms" << tsms << endl;
   // Convert time into frame number
   qint64 DesiredFrameNumber = av_rescale(tsms,pFormatCtx->streams[videoStream]->time_base.den,pFormatCtx->streams[videoStream]->time_base.num);
   DesiredFrameNumber/=1000;

   return seekFrame(DesiredFrameNumber);
}
/**
  \brief Seek to frame
**/
bool DecodeThread::seekFrame(qint64 frame)
{
   //printf("**** seekFrame to %d. LLT: %d. LT: %d. LLF: %d. LF: %d. LastFrameOk: %d\n",(int)frame,LastLastFrameTime,LastFrameTime,LastLastFrameNumber,LastFrameNumber,(int)LastFrameOk);
    cout << "frame" << frame << endl;
   // Seek if:
   // - we don't know where we are (Ok=false)
   // - we know where we are but:
   //    - the desired frame is after the last decoded frame (this could be optimized: if the distance is small, calling decodeSeekFrame may be faster than seeking from the last key frame)
   //    - the desired frame is smaller or equal than the previous to the last decoded frame. Equal because if frame==LastLastFrameNumber we don't want the LastFrame, but the one before->we need to seek there
   //if( (LastFrameOk==false) || ((LastFrameOk==true) && (frame<=LastLastFrameNumber || frame>LastFrameNumber) ) )
   //{
      //printf("\t avformat_seek_file\n");
      if(avformat_seek_file(pFormatCtx,videoStream,frame,frame,frame,AVSEEK_FLAG_FRAME)<0)
         return false;

      avcodec_flush_buffers(pVideoCodecCtx);

      //DesiredFrameNumber = frame;
      //LastFrameOk=false;
   //}
   //printf("\t decodeSeekFrame\n");
    return true;
   //return decodeSeekFrame(frame);
}

bool DecodeThread::isOk()
{
   return ok;
}


void DecodeThread::run()
{
    if (!ok) return;
    const int MAX_LIVES = 10000;
    int lives = MAX_LIVES;
    QTime timer;
    timer.start();
    forever
    {
        // Read a frame
        //cout << "I'm stucked here!" << endl;
        if(av_read_frame(pFormatCtx, &packet)<0)
        {
            if (pFormatCtx->pb->eof_reached)
            {
                cout << "end of stream" << endl;
                break;
            }
            //cout << "Read frame failed!! Remaining Lives: " << lives << endl;
            if (lives > 0)
            {
                lives--;
                continue;
            }
            else
            {
                cout << "out of live" << endl;
                break;                             // Frame read failed (e.g. end of stream)
            }
        }

        lives = MAX_LIVES;
        if (timer.elapsed() > 1000)
            cout << fileName.toStdString() << " time: " << timer.elapsed() << '\t';
        //cout << "Packet of stream " << packet.stream_index << ", size " << packet.size << endl;

        if(packet.stream_index==videoStream)
        {
            videoMutex->lock();
            videoQueue.append(packet);
            videoMutex->unlock();
        }
        else av_free_packet(&packet);

        if (timer.elapsed() > 1000) cout << timer.elapsed() << endl;
        timer.restart();
    }
}
